---
title: "Unit2_Module2_test"
author: "Rowan Moody"
date: 2020-4-2
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Unit2_Module2_test}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

.5: Read in necessary datasets
```{r}
library(geospaar)

farmers <- system.file("extdata/farmer_spatial.csv", package = "geospaar") %>% 
  read_csv() 
roads <- system.file("extdata/roads.shp", package = "geospaar") %>% st_read
districts <- system.file("extdata/districts.shp", package = "geospaar") %>% 
  st_read
```

1: Create a subset of districts by extracting districts 22, 26, 53, and 54. Call it districts_ss. Use the extent of districts_ss (extent(districts_ss)) to define the extent of a new raster r, which should have a resolution of 0.1°. Use r as a template for creating two new rasters, rsamp and rrand. rsamp should be filled with randomly selected integers ranging between 10 and 50. rrandn should be filled with random numbers drawn from a normal distribution (rnorm) that has a mean of 30 and standard deviation of 5. Use a seed of 1 in set.seed. Stack rsamp and runi (name the stack s), mask that by districts_ss, and plot s using plot_noaxes. (Ref: Chunks 1, 3, 4, 16)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
districts_ss <- districts %>% slice(22, 26, 53, 54)
r <- raster(x = extent(districts_ss), res = 0.1, crs = crs(districts_ss))

rsamp <- r
rrand <- r

set.seed(1)
values(rsamp) <- sample(10:50, size = ncell(rsamp), replace = TRUE)
values(rrand) <- rnorm(n = ncell(rrand), mean = 30, sd = 5)

l <- list(rsamp, rrand)
s <- stack(l) %>% mask(., mask = districts_ss)
plot_noaxes(s)
```


2: Disaggregate s[[1]] to a resolution of 0.025°, using bilinear interpolation, calling the result s2_1d. Select all areas of s2_1d that have values > 35, creating a new raster s2_1gt35. Set the values of s2_1gt35 that equal 0 to NA. Then convert the resulting raster into an sf object called s2poly. Plot the resulting polygons over s2_1d. (Ref: Chunks 10, 22, 37)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
s2_1d <- disaggregate(x = s[[1]], fact = 4, method = "bilinear")

s2_lgt35 <- s2_1d > 35
s2_lgt35[s2_lgt35 == 0] <- NA

s2poly <- rasterToPolygons(x = s2_lgt35, dissolve = TRUE) %>% st_as_sf()

plot_noaxes(s2_1d)
plot(s2poly, add = TRUE, col = "red")
```

3: Create a new grid from the extent of districts that has a resolution of 0.5° (call it zamr), assigning all cells a value of 1. Then recreate the farmersr dataset–a raster that sums the number of farmers falling within each grid cell. Mask the results using districts, and then plot the result onto a grey background of Zambia. (Ref: Chunk 8, 37)

```{r, fig.width=7, fig.height=4, fig.align = "center"}
zamr <- raster(x = extent(districts), res = 0.5, crs = crs(districts))
values(zamr) <- 1

farmersr <- farmers %>% distinct(uuid, .keep_all = TRUE) %>% 
  dplyr::select(x, y) %>% mutate(count = 1) %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326) %>% 
  rasterize(x = ., y = zamr, field = "count", fun = sum) %>% 
  mask(.,mask = districts)

par(mar = c(0, 0, 1, 0))
districts %>% st_union %>% plot(col = "grey", border = "grey")
plot(farmersr, add = TRUE)
```

4: Convert the rasterized farmers counts (farmersr) back into an sf points object farmersrpts. Create a new version of zamr at 0.05°, and then calculate the distance between these points and every other location in Zambia, creating an output grid of distances, called dist_to_farmers, which you mask by districts. Plot dist_to_farmers in kilometers (i.e. divide it by 1000) using plot_no_axes, with farmersrpts overlaid as black solid circles. (Ref: Chunks 8, 10, 47)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
farmersrpts <- rasterToPoints(x = farmersr, spatial = TRUE) %>% st_as_sf()
zamr <- raster(x = extent(districts), res = 0.05, crs = crs(districts))

dist_to_farmers <- distanceFromPoints(object = zamr, xy = farmersrpts) %>% 
  mask(., mask = districts)

par(mar = c(0, 0, 1, 0))
plot_noaxes(dist_to_farmers / 1000, main = "Distance to Farmers", 
            legend.args = list(text = "km"))
plot(farmersrpts, col = "black", pch = 20, cex = .75, add = TRUE)
```

5: Use raster’s getData function to grab WorldClim’s mean temperature (“tmean”) dataset at a resolution of 2.5 (note this is not degrees, but minutes of a degree), and download it to somewhere on your local disk. That will give a global scale RasterBrick with 12 layers, with each layer representing the average monthly temperature for each grid cell on the planet. Crop that brick to the extent of districts, and then calculate the annual mean temperature for each cell. Mask the result using districts, and divide it by 10 to get temperature in °C in your final raster, zamtmean. Plot the result. (Ref: Chunk 17, 18, 48)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
#wctmean <- getData("worldclim", var = "tmean", res = 2.5, path = "notebooks/data")
#^This code runs and I downloaded this dataset onto my computer drive.  
#For some reason when knitting this vignette, I get an error stating 
  #"path = "notebooks/data" not found.  
wctmean <- getData("worldclim", var = "tmean", res = 2.5, path = tempdir())

zamtmean_annual <- crop(x = wctmean, y = districts) %>% calc(., mean) %>% 
  mask(., mask = districts)

zamtmean <- zamtmean_annual / 10 #convert to celsius

plot_noaxes(zamtmean, legend.args = list(expression(paste("C", degree))))
```

6: Classify the temperature data into three categories, low, medium, and high, using <20°, 20-24°, and >24° as the break points for determining the classes. Use the reclassify function rather than the cut function, which means you need to set up a reclassification matrix, which you should do like this:

#trng <- cellStats(zamtmean, range)
#reclmat <- cbind(c(floor(trng[1]), 20, 24), c(20, 24, ceiling(trng[2])), 1:3)

Here cellStats is helping to find the values of tmin and tmax, which respectively define the lower bound of the “low” class and the upper bound of the “high” class. What are the functions floor and ceiling doing (answer this in your vignette)? Call the reclassified temperature raster zamtclass. Make the map using plot_noaxes with a categorical legend, and using the colors “blue”, “yellow2”, and “red” for the three classes. (Ref: Chunk 26, 39)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
trng <- cellStats(zamtmean, range)
reclmat <- cbind(c(floor(trng[1]), 20, 24), c(20, 24, ceiling(trng[2])), 1:3)

zamtclass <- reclassify(x = zamtmean, rcl = reclmat, include.lowest = TRUE)

cols <- c("blue", "yellow2", "red")
plot_noaxes(zamtclass, legend = FALSE, main = "Mean Annual Temp", col = cols, 
            mar = c(0, 0, 1, 0))
legend(x = "bottomright", legend = c("High", "Intermediate", "Low"), 
       pch = 15, pt.cex = 3, col = rev(cols), bty = "n")
```

Description of Floor & Ceiling Functions:

The Floor function is setting the first value of the trng object as the low value in the classification. The Ceiling function is setting the second value of the trng object as the high value in the classification.


7: Load up the zamprec dataset (data(zamprec)) that comes with geospaar, then calculate the mean precipitation within each temperature zone defined by zamtclass. Call the resulting matrix z. Map the mean zonal precipitation values in z onto each temperature zone (using the subs function with zamtclass as the target; remember that zonal returns a matrix, and that subs requires a data.frame or tibble for its y argument). Call the new raster zamprecz, and then plot it using plot_noaxes, with a custom legend (as done in Task 6), using the rounded zonal mean values (rounded) as the legend labels (legend = round(z$mean)). Use colors “yellow2”, “green3”, and “blue” for the three classes (Ref: Chunks 32, 33, 39)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
data(zamprec)

z <- zonal(x = zamprec, z = zamtclass, fun = "mean")
zamprecz <- z %>% as_tibble() %>% 
  raster::subs(x = zamtclass, y = ., by = "zone")

plot_noaxes(zamprecz)

cols2 <- c("yellow2", "green3", "blue")
plot_noaxes(zamprecz, legend = FALSE, 
            main = "Mean Precipitation by Temperature Zone", 
            col = cols2, mar = c(0, 0, 1, 0))
legend(x = "bottomright", legend = round(z[1:3, 2]), 
       pch = 15, pt.cex = 3, col = rev(cols2), bty = "n")
```

8: Use getData again to download the elevation raster for Zambia (call it dem). Aggregate it to the same resolution as zamtmean, using the default mean aggregation (the factor you need is 5). Call that dem5. Use terrain to calculate aspect from dem5 (call it aspect), selecting degrees as the output value. Then find all west-facing aspects (aspects >247.5 and <292.5), and all east facing aspects (>67.5 and <112.5), making new rasters respectively named west and east, e.g. west <- aspect > 247.5 & aspect < 292.5). Stack these together with aspect and make a three-panel plot with plot_noaxes with titles “Aspect”, “West”, and “East”. (Ref: Chunks 37, 42)

```{r, fig.width=7, fig.height=4, fig.align = "center"}
#dem <- getData(name = "alt", country = "ZMB", path = "notebooks/data")
#^This code runs and I downloaded this dataset onto my computer drive.  
#For some reason when knitting this vignette, I get an error stating 
  #"path = "notebooks/data" not found.  
dem <- getData(name = "alt", country = "ZMB", path = tempdir())
dem5 <- raster::aggregate(x = dem, fact = 5, fun = mean)
# same resolution, but different extents

dem_5 <- resample(dem, zamtmean)
#This gives right res and extent

res(zamtmean) == res(dem5)
res(zamtmean) == res(dem_5)
#I tried the rest of exercise 8 and 9 with both dem5 and dem_5, and they showed
#different results due to the difference in extent with zamtmean.  I will use 
#dem_5 in the next exercise, as I believe it's important to have the same 
#reference system AND spatial extent in analysis.  

aspect <- terrain(x = dem_5, opt = "aspect", unit = "degrees")
west <- aspect > 247.5 & aspect < 292.5
east <- aspect > 67.5 & aspect < 112.5

aspect_we <- stack(aspect, west, east)
direction <- c("Aspect", "West", "East")
names(aspect_we) <- direction
plot_noaxes(aspect_we, nr = 1)
```

9: Using a random seed of 1, create two random samples of 100 each. The first one should be collected from within the west-facing cells (i.e. only be drawn from cells in west that have a cell of one), and the second from east-facing cells. To do this, set the cells equal to 0 in east and west to NA (e.g. west[west == 0] <- NA). Once you have collected those, convert the resulting sp objects to sf, and use those two sets of points to extract temperature values from zamtmean into a tibble temp_stats, which is going to look this:

#temp_stats <- bind_rows(
#  tibble(temp = raster::extract(zamtmean, westpts), dat = "West"), 
#  tibble(temp = raster::extract(zamtmean, eastpts), dat = "East")
#)

Then use temp_stats with ggplot to make side-by-side boxplots to compare the distributions of west and east facing temperatures, modeled on the example in Chunk 40 #4. (Ref: Chunks 37, 40)

```{r, fig.width=5, fig.height=4, fig.align = "center"}
west[west == 0] <- NA
east[east == 0] <- NA

set.seed(1)
westpts <- sampleRandom(x = west, size = 100, cells = TRUE, sp = TRUE)
eastpts <- sampleRandom(x = east, size = 100, cells = TRUE, sp = TRUE)

temp_stats <- bind_rows(
  tibble(temp = raster::extract(zamtmean, westpts), dat = "West"), 
  tibble(temp = raster::extract(zamtmean, eastpts), dat = "East")
) 

temp_stats %>% ggplot() +
  geom_boxplot(mapping = aes(y = temp, fill = dat), position = "dodge2") +
  scale_fill_manual(values = c("orange2", "green3")) + 
  ggtitle("Temperature distributions") + xlab(NULL) + ylab(expression(paste("Celsius", degree)))
```

10: Extra credit worth (5 points). Extract the centroids from each district in districts (call it dcent), and reproject the points to Albers, using the st_crs(roads). Reproject zamtmean to Albers also, making the new resolution (5 km, i.e. 5000 m), using bilinear interpolation (call it zamtmeanalb). Then use dcent to extract the temperature values from zamtmeanalb (add the values to dcent as a new variable “temp” using mutate). Use gstat to create an IDW model (call it idw). To make the IDW work, which isn’t sf compliant, some extra work will be required, as shown below (this is the step needed after the extract of temperature values)

dcent <- bind_cols(
  dcent %>% data.frame %>% dplyr::select(-geometry) %>% as_tibble, 
  st_coordinates(dcent) %>% as_tibble
) %>% rename(x = X, y = Y)

This yields a tibble with columns x and y that are needed by gstat. After running gstat, map the interpolated temperatures using zamtmeanalb as a target object (it won’t be overwritten) and idw as the model. Make sure you mask the result to the boundaries of Zambia, using zamtmeanalb as the mask. Call the new interpolated, masked grid zamtidw. Plot the result side by side with zamtmeanalb for comparison using plot_noaxes with titles “Real Temperature” and “IDW Temperature”. (Refs: Chunks 46, 49)

